<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Truth Miner</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #333333;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Adjust canvas for device pixel ratio and screen size
        function resizeCanvas() {
            canvas.width = window.innerWidth * devicePixelRatio;
            canvas.height = window.innerHeight * devicePixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            ctx.scale(devicePixelRatio, devicePixelRatio);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game constants
        const PATH_WIDTH = window.innerWidth * 0.15;
        const WORKER_SIZE = PATH_WIDTH * 0.5;
        const TRIANGLE_SIZE = WORKER_SIZE * 0.3;
        const BIN_SIZE = PATH_WIDTH * 0.7;
        const PATH_COLOR = '#777777';
        const WORKER_COLOR = '#000000';
        const BIN_COLOR = '#000000';
        const MINE_Y = window.innerHeight * 0.85;
        const MINE_SPACING = 100; // 100 pixels below each mine
        const SHAFT_X = window.innerWidth * 0.15;
        const CART_Y = window.innerHeight * 0.15;
        const MINE_START_X = window.innerWidth * 0.85;
        const MINE_END_X = SHAFT_X;
        const SHAFT_END_Y = CART_Y;
        const CART_START_X = SHAFT_X;
        const CART_END_X = window.innerWidth * 0.85;
        const BUTTON_X = window.innerWidth * 0.85 - 20;
        const MAX_MINES = 10; // Up to Mine 10
        const COUNTER_Y = window.innerHeight * 0.5; // Position in the game world
        const BUTTON_WIDTH = window.innerWidth * 0.1;
        const BUTTON_HEIGHT = window.innerHeight * 0.1;

        // Game state
        let truthCount = 0;
        let totalTruthsMined = 0;
        let mines = [
            {
                y: MINE_Y,
                worker: {
                    x: MINE_START_X,
                    y: MINE_Y,
                    speed: 3, // Start at 3
                    level: 1,
                    hasTruth: false,
                    movingToBin: false,
                    waiting: true,
                    triangles: 0,
                    carryCapacity: 6 // Start at 6
                },
                bin: { x: MINE_END_X, y: MINE_Y, triangles: 3 },
                name: 'Mine 1'
            }
        ];
        let workers = {
            shaft: [
                {
                    x: SHAFT_X,
                    y: SHAFT_END_Y, // Start at the top (shaft bin)
                    speed: 6, // Start at 6
                    level: 1,
                    hasTruth: false,
                    movingToBin: false,
                    waiting: false,
                    triangles: 0,
                    carryCapacity: 12, // Start at 12
                    movingDown: true // Track direction
                }
            ],
            cart: [
                {
                    x: CART_START_X,
                    y: CART_Y,
                    speed: 3, // Start at 3
                    level: 1,
                    hasTruth: false,
                    movingToBin: false,
                    waiting: true,
                    triangles: 0,
                    carryCapacity: 9 // Start at 9
                }
            ]
        };
        let bins = {
            shaft: { x: SHAFT_X, y: SHAFT_END_Y, triangles: 0 },
            cart: { x: CART_END_X, y: CART_Y, triangles: 0 }
        };

        // Scrolling state
        let cameraY = 0;
        let worldHeight = window.innerHeight;
        let isDragging = false;
        let startY = 0;
        let startCameraY = 0;

        // Automation state
        let isAutoEnabled = false;

        // Button definitions
        let buttons = [
            { name: 'Cart', worker: 'cart', x: BUTTON_X, y: window.innerHeight * 0.25, width: BUTTON_WIDTH, height: BUTTON_HEIGHT },
            { name: 'Shaft', worker: 'shaft', x: BUTTON_X, y: window.innerHeight * 0.45, width: BUTTON_WIDTH, height: BUTTON_HEIGHT },
            { name: 'Mine 1', worker: 'mine', index: 0, x: MINE_START_X - BUTTON_WIDTH / 2, y: MINE_Y - BUTTON_HEIGHT / 2, width: BUTTON_WIDTH, height: BUTTON_HEIGHT },
            { name: 'AUTO', action: 'toggleAuto', x: BUTTON_X, y: window.innerHeight * 0.65, width: BUTTON_WIDTH, height: BUTTON_HEIGHT }
        ];

        // Evolution stages for "Drink Milk" section
        const stages = [
            { name: 'Just', triangleColor: '#808080', threshold: 0 },
            { name: 'Wise', triangleColor: '#FFD800', threshold: 5000 },
            { name: 'Love', triangleColor: '#00CC00', threshold: 10000 },
            { name: 'Just Wise Love', triangleColor: '#FFFFFF', threshold: 15000 }
        ];
        let currentStage = stages[0]; // Start with "Just"

        // Reset game state except totalTruthsMined
        function resetGameState() {
            truthCount = 0;
            mines = [
                {
                    y: MINE_Y,
                    worker: {
                        x: MINE_START_X,
                        y: MINE_Y,
                        speed: 3, // Start at 3
                        level: 1,
                        hasTruth: false,
                        movingToBin: false,
                        waiting: true,
                        triangles: 0,
                        carryCapacity: 6 // Start at 6
                    },
                    bin: { x: MINE_END_X, y: MINE_Y, triangles: 3 },
                    name: 'Mine 1'
                }
            ];
            workers = {
                shaft: [
                    {
                        x: SHAFT_X,
                        y: SHAFT_END_Y,
                        speed: 6, // Start at 6
                        level: 1,
                        hasTruth: false,
                        movingToBin: false,
                        waiting: false,
                        triangles: 0,
                        carryCapacity: 12, // Start at 12
                        movingDown: true
                    }
                ],
                cart: [
                    {
                        x: CART_START_X,
                        y: CART_Y,
                        speed: 3, // Start at 3
                        level: 1,
                        hasTruth: false,
                        movingToBin: false,
                        waiting: true,
                        triangles: 0,
                        carryCapacity: 9 // Start at 9
                    }
                ]
            };
            bins = {
                shaft: { x: SHAFT_X, y: SHAFT_END_Y, triangles: 0 },
                cart: { x: CART_END_X, y: CART_Y, triangles: 0 }
            };
            buttons = [
                { name: 'Cart', worker: 'cart', x: BUTTON_X, y: window.innerHeight * 0.25, width: BUTTON_WIDTH, height: BUTTON_HEIGHT },
                { name: 'Shaft', worker: 'shaft', x: BUTTON_X, y: window.innerHeight * 0.45, width: BUTTON_WIDTH, height: BUTTON_HEIGHT },
                { name: 'Mine 1', worker: 'mine', index: 0, x: MINE_START_X - BUTTON_WIDTH / 2, y: MINE_Y - BUTTON_HEIGHT / 2, width: BUTTON_WIDTH, height: BUTTON_HEIGHT },
                { name: 'AUTO', action: 'toggleAuto', x: BUTTON_X, y: window.innerHeight * 0.65, width: BUTTON_WIDTH, height: BUTTON_HEIGHT }
            ];
            cameraY = 0;
            worldHeight = window.innerHeight;
            isDragging = false;
            startY = 0;
            startCameraY = 0;
            isAutoEnabled = false;
        }

        // Draw diamond shape
        function drawDiamond(x, y, size, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x + size, y);
            ctx.lineTo(x, y + size);
            ctx.lineTo(x - size, y);
            ctx.closePath();
            ctx.fill();
        }

        // Draw triangle with dynamic color
        function drawTriangle(x, y, size, color) {
            ctx.fillStyle = currentStage.triangleColor;
            ctx.beginPath();
            ctx.moveTo(x, y - size);
            ctx.lineTo(x + size * 0.866, y + size * 0.5);
            ctx.lineTo(x - size * 0.866, y + size * 0.5);
            ctx.closePath();
            ctx.fill();
        }

        // Draw worker with triangles
        function drawWorker(worker) {
            drawDiamond(worker.x, worker.y - cameraY, WORKER_SIZE, WORKER_COLOR);
            if (worker.hasTruth) {
                drawTriangle(worker.x, worker.y - cameraY - WORKER_SIZE * 0.5, TRIANGLE_SIZE);
                drawTriangle(worker.x - WORKER_SIZE * 0.5, worker.y - cameraY, TRIANGLE_SIZE);
                drawTriangle(worker.x + WORKER_SIZE * 0.5, worker.y - cameraY, TRIANGLE_SIZE);
            }
        }

        // Draw bin with triangles
        function drawBin(bin) {
            ctx.fillStyle = BIN_COLOR;
            ctx.fillRect(bin.x - BIN_SIZE / 2, bin.y - cameraY - BIN_SIZE / 2, BIN_SIZE, BIN_SIZE);
            if (bin.triangles > 0) {
                drawTriangle(bin.x, bin.y - cameraY - BIN_SIZE * 0.3, TRIANGLE_SIZE);
                drawTriangle(bin.x - BIN_SIZE * 0.3, bin.y - cameraY, TRIANGLE_SIZE);
                drawTriangle(bin.x + BIN_SIZE * 0.3, bin.y - cameraY, TRIANGLE_SIZE);
            }
        }

        // Draw paths
        function drawPaths() {
            ctx.fillStyle = PATH_COLOR;
            mines.forEach(mine => {
                ctx.fillRect(0, mine.y - cameraY - PATH_WIDTH / 2, window.innerWidth, PATH_WIDTH);
            });
            ctx.fillRect(0, CART_Y - cameraY - PATH_WIDTH / 2, window.innerWidth, PATH_WIDTH);
            let lowestY = mines.reduce((max, m) => Math.max(max, m.y), MINE_Y);
            ctx.fillRect(SHAFT_X - PATH_WIDTH / 2, CART_Y - cameraY, PATH_WIDTH, lowestY - CART_Y);
        }

        // Draw Truth counter and related text
        function drawCounter() {
            ctx.fillStyle = '#FFFFFF';
            ctx.font = `${window.innerWidth * 0.05}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            let counterY = COUNTER_Y - cameraY; // Scroll with the game world
            ctx.fillText(currentStage.name, window.innerWidth * 0.5, counterY - 125);
            ctx.fillText(`Truth: ${truthCount}`, window.innerWidth * 0.5, counterY);
            let displayMined = totalTruthsMined >= 99999 ? 99999 : totalTruthsMined;
            ctx.fillText(`${displayMined}`, window.innerWidth * 0.5, counterY + 125);
        }

        // Draw bin counters
        function drawBinCounters() {
            ctx.fillStyle = '#FFFFFF';
            ctx.font = `${window.innerWidth * 0.05}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            mines.forEach(mine => {
                ctx.fillText(`${mine.bin.triangles}`, mine.bin.x, mine.bin.y - cameraY + BIN_SIZE / 2 + 10);
            });
            ctx.textBaseline = 'bottom';
            ctx.fillText(`${bins.shaft.triangles}`, bins.shaft.x, bins.shaft.y - cameraY - BIN_SIZE / 2 - 10);
        }

        // Draw buttons
        function drawButtons() {
            buttons.forEach(button => {
                if (button.name === 'AUTO') {
                    // Black when enabled and all 10 mines exist, green when enabled otherwise, grey when disabled
                    ctx.fillStyle = isAutoEnabled ? (mines.length === MAX_MINES ? '#000000' : '#00FF00') : '#555555';
                } else {
                    ctx.fillStyle = '#555555';
                }
                ctx.fillRect(button.x, button.y - cameraY, button.width, button.height); // Adjust button position with camera
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `${window.innerWidth * 0.03}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let displayText = button.name;
                if (button.worker && button.worker !== 'mine') {
                    let level = workers[button.worker][0].level;
                    let cost = level * 10;
                    displayText = `${button.name} (${cost})`;
                } else if (button.worker === 'mine' && button.index < mines.length) {
                    let level = mines[button.index].worker.level;
                    let cost = level * 10;
                    displayText = `${button.name} (${cost})`;
                }
                ctx.fillText(displayText, button.x + button.width / 2, button.y - cameraY + button.height / 2);
            });
        }

        // Update mine worker
        function updateMineWorker(mine) {
            let worker = mine.worker;
            if (worker.waiting) {
                if (mine.bin.triangles >= 3 || !worker.hasTruth) {
                    worker.waiting = false;
                    worker.movingToBin = true;
                    worker.hasTruth = true;
                    worker.triangles = Math.min(3, worker.carryCapacity); // Respect carry capacity
                }
            } else if (worker.movingToBin) {
                let dx = MINE_END_X - worker.x;
                worker.x += Math.sign(dx) * worker.speed;
                if (Math.abs(dx) < worker.speed) {
                    worker.x = MINE_END_X;
                    worker.movingToBin = false;
                    mine.bin.triangles += worker.triangles;
                    worker.hasTruth = false;
                    worker.triangles = 0;
                }
            } else {
                let dx = MINE_START_X - worker.x;
                worker.x += Math.sign(dx) * worker.speed;
                if (Math.abs(dx) < worker.speed) {
                    worker.x = MINE_START_X;
                    worker.waiting = true;
                }
            }
        }

        // Update shaft worker with prioritized collection
        function updateShaftWorker(worker) {
            let sortedMines = mines.slice().sort((a, b) => a.y - b.y); // Sort mines from top to bottom

            // If worker is full, force moving up to the shaft bin
            if (worker.triangles >= worker.carryCapacity) {
                worker.movingToBin = true;
                worker.movingDown = false;
            }

            if (worker.movingToBin) {
                // Moving up to the shaft bin
                let dy = SHAFT_END_Y - worker.y;
                worker.y += Math.sign(dy) * worker.speed;
                if (Math.abs(dy) < worker.speed) {
                    worker.y = SHAFT_END_Y;
                    worker.movingToBin = false;
                    bins.shaft.triangles += worker.triangles;
                    worker.hasTruth = false;
                    worker.triangles = 0;
                    worker.movingDown = true; // Start moving down after dumping
                }
            } else if (worker.movingDown) {
                // Find the first mine with triangles >= 3, or move to the next mine if none
                let targetMine = null;
                for (let mine of sortedMines) {
                    if (mine.y >= worker.y && mine.bin.triangles >= 3) {
                        targetMine = mine;
                        break;
                    }
                }

                if (!targetMine && worker.y < sortedMines[sortedMines.length - 1].y) {
                    // No non-empty bins at or below current position, move to next mine
                    let nextMine = sortedMines.find(m => m.y > worker.y);
                    if (nextMine) {
                        let dy = nextMine.y - worker.y;
                        worker.y += Math.sign(dy) * worker.speed;
                        if (Math.abs(dy) < worker.speed) {
                            worker.y = nextMine.y;
                        }
                    }
                } else if (targetMine) {
                    // Move to the target mine's y position
                    let dy = targetMine.y - worker.y;
                    if (Math.abs(dy) > worker.speed) {
                        worker.y += Math.sign(dy) * worker.speed;
                    } else {
                        worker.y = targetMine.y;
                        // Collect triangles if not full
                        if (targetMine.bin.triangles >= 3 && worker.triangles < worker.carryCapacity) {
                            let trianglesToTake = Math.min(targetMine.bin.triangles, worker.carryCapacity - worker.triangles);
                            targetMine.bin.triangles -= trianglesToTake;
                            worker.triangles += trianglesToTake;
                            worker.hasTruth = worker.triangles > 0;
                        }
                        // If full, go dump
                        if (worker.triangles >= worker.carryCapacity) {
                            worker.movingDown = false;
                            worker.movingToBin = true;
                        }
                    }
                } else {
                    // At the lowest mine with no triangles to collect, go dump if carrying any
                    if (worker.triangles > 0) {
                        worker.movingDown = false;
                        worker.movingToBin = true;
                    }
                }
            }
        }

        // Update cart worker to haul any value except 0 and reset on stage change
        function updateCartWorker(worker) {
            if (worker.waiting) {
                if (bins.shaft.triangles > 0) { // Haul any value greater than 0
                    worker.waiting = false;
                    worker.movingToBin = true;
                    let trianglesToTake = Math.min(bins.shaft.triangles, worker.carryCapacity);
                    bins.shaft.triangles -= trianglesToTake;
                    worker.hasTruth = true;
                    worker.triangles = trianglesToTake;
                }
            } else if (worker.movingToBin) {
                let dx = CART_END_X - worker.x;
                worker.x += Math.sign(dx) * worker.speed;
                if (Math.abs(dx) < worker.speed) {
                    worker.x = CART_END_X;
                    worker.movingToBin = false;
                    bins.cart.triangles += worker.triangles;
                    truthCount += worker.triangles;

                    if (totalTruthsMined < 99999) {
                        let previousTotal = totalTruthsMined;
                        totalTruthsMined += worker.triangles;

                        // Check for stage transition
                        let previousStage = currentStage;
                        for (let i = stages.length - 1; i >= 0; i--) {
                            if (totalTruthsMined >= stages[i].threshold) {
                                currentStage = stages[i];
                                break;
                            }
                        }

                        // If stage changed, reset the game
                        if (currentStage !== previousStage) {
                            resetGameState();
                        }
                    }

                    worker.hasTruth = false;
                    worker.triangles = 0;
                    bins.cart.triangles = 0;
                }
            } else {
                let dx = CART_START_X - worker.x;
                worker.x += Math.sign(dx) * worker.speed;
                if (Math.abs(dx) < worker.speed) {
                    worker.x = CART_START_X;
                    worker.waiting = true;
                }
            }
        }

        // Find the cheapest upgrade
        function findCheapestUpgrade() {
            let cheapestButton = null;
            let minCost = Infinity;

            buttons.forEach(button => {
                // Skip mine buttons if all 10 mines are created
                if (button.worker && !(mines.length === MAX_MINES && button.worker === 'mine')) {
                    let level;
                    if (button.worker === 'mine' && button.index < mines.length) {
                        level = mines[button.index].worker.level;
                    } else if (button.worker === 'cart' || button.worker === 'shaft') {
                        level = workers[button.worker][0].level;
                    }
                    let cost = level * 10;
                    if (cost < minCost) {
                        minCost = cost;
                        cheapestButton = button;
                    }
                }
            });

            return { button: cheapestButton, cost: minCost };
        }

        // Perform the upgrade for a given button
        function performUpgrade(button) {
            let level, workerGroup;
            if (button.worker === 'mine' && button.index < mines.length) {
                workerGroup = [mines[button.index].worker];
                level = workerGroup[0].level;
            } else {
                workerGroup = workers[button.worker];
                level = workerGroup[0].level;
            }
            let cost = level * 10;
            if (truthCount >= cost) {
                truthCount -= cost;
                // Increment level
                workerGroup.forEach(worker => {
                    worker.level++;
                    // Update speed and capacity based on worker type
                    if (button.worker === 'shaft') {
                        worker.speed = 6 + (worker.level - 1) * 2; // Start at 6, +2 per level
                        worker.carryCapacity = 12 + (worker.level - 1) * 6; // Start at 12, +6 per level
                    } else if (button.worker === 'cart') {
                        worker.speed = 3 + (worker.level - 1) * 1; // Start at 3, +1 per level
                        worker.carryCapacity = 9 + (worker.level - 1) * 6; // Start at 9, +6 per level
                    } else {
                        worker.speed = 3 + (worker.level - 1) * 0.25; // Mine: Start at 3, +0.25 per level
                        worker.carryCapacity = 6 + (worker.level - 1) * 1; // Mine: Start at 6, +1 per level
                    }
                });

                // Check for new mine creation based on specific mine levels
                if (button.worker === 'mine' && button.index < mines.length && mines.length < MAX_MINES) {
                    let createNewMine = false;
                    let newMineIndex = mines.length + 1;

                    if (mines.length === 1 && mines[0].worker.level >= 2) { // Mine 2 when Mine 1 is level 2
                        createNewMine = true;
                    } else if (mines.length === 2 && mines[1].worker.level >= 2) { // Mine 3 when Mine 2 is level 2
                        createNewMine = true;
                    } else if (mines.length === 3 && mines[2].worker.level >= 2) { // Mine 4 when Mine 3 is level 2
                        createNewMine = true;
                    } else if (mines.length === 4 && mines[3].worker.level >= 3) { // Mine 5 when Mine 4 is level 3
                        createNewMine = true;
                    } else if (mines.length === 5 && mines[4].worker.level >= 3) { // Mine 6 when Mine 5 is level 3
                        createNewMine = true;
                    } else if (mines.length === 6 && mines[5].worker.level >= 3) { // Mine 7 when Mine 6 is level 3
                        createNewMine = true;
                    } else if (mines.length === 7 && mines[6].worker.level >= 4) { // Mine 8 when Mine 7 is level 4
                        createNewMine = true;
                    } else if (mines.length === 8 && mines[7].worker.level >= 4) { // Mine 9 when Mine 8 is level 4
                        createNewMine = true;
                    } else if (mines.length === 9 && mines[8].worker.level >= 5) { // Mine 10 when Mine 9 is level 5
                        createNewMine = true;
                    }

                    if (createNewMine) {
                        let newMineY = mines[mines.length - 1].y + MINE_SPACING;
                        mines.push({
                            y: newMineY,
                            worker: {
                                x: MINE_START_X,
                                y: newMineY,
                                speed: 3, // Start at 3
                                level: 1,
                                hasTruth: false,
                                movingToBin: false,
                                waiting: true,
                                triangles: 0,
                                carryCapacity: 6 // Start at 6
                            },
                            bin: { x: MINE_END_X, y: newMineY, triangles: 3 },
                            name: `Mine ${newMineIndex}`
                        });
                        // Add new mine button
                        buttons.push({
                            name: `Mine ${newMineIndex}`,
                            worker: 'mine',
                            index: mines.length - 1,
                            x: MINE_START_X - BUTTON_WIDTH / 2,
                            y: newMineY - BUTTON_HEIGHT / 2,
                            width: BUTTON_WIDTH,
                            height: BUTTON_HEIGHT
                        });
                        // Increase shaft worker capacity by 9
                        workers.shaft[0].carryCapacity += 9;
                        // Increase cart worker capacity by 6
                        workers.cart[0].carryCapacity += 6;
                    }
                }
            }
        }

        // Update world height for scrolling
        function updateWorldHeight() {
            let lowestY = mines.reduce((max, m) => Math.max(max, m.y), MINE_Y);
            worldHeight = lowestY + PATH_WIDTH; // Add padding at the bottom
        }

        // Handle touch start for scrolling and button clicks
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = (touch.clientX - rect.left) / (rect.width / window.innerWidth);
            const y = (touch.clientY - rect.top) / (rect.height / window.innerHeight);

            // Check if the touch is on a button
            let isButtonClick = false;
            buttons.forEach(button => {
                let adjustedY = y + cameraY;
                if (x >= button.x && x <= button.x + button.width && adjustedY >= button.y && adjustedY <= button.y + button.height) {
                    isButtonClick = true;
                    if (button.action === 'toggleAuto') {
                        isAutoEnabled = !isAutoEnabled;
                    } else {
                        handleClick(x, y);
                    }
                }
            });

            // If not a button click, start dragging
            if (!isButtonClick) {
                isDragging = true;
                startY = touch.clientY;
                startCameraY = cameraY;
            }
        });

        // Handle touch move for scrolling
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDragging) {
                const touch = e.touches[0];
                const deltaY = touch.clientY - startY;
                cameraY = startCameraY - deltaY * (window.innerHeight / canvas.height); // Adjust for device pixel ratio

                // Clamp cameraY to keep the game world in view
                let lowestY = mines.reduce((max, m) => Math.max(max, m.y), MINE_Y);
                worldHeight = lowestY + PATH_WIDTH;
                cameraY = Math.max(CART_Y - window.innerHeight / 2, Math.min(cameraY, worldHeight - window.innerHeight / 2));
            }
        });

        // Handle touch end for scrolling
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDragging = false;
        });

        // Handle upgrades and mine unlocking
        function handleClick(x, y) {
            buttons.forEach(button => {
                let adjustedY = y + cameraY;
                if (button.worker && x >= button.x && x <= button.x + button.width && adjustedY >= button.y && adjustedY <= button.y + button.height) {
                    performUpgrade(button);
                }
            });
        }

        // Automate upgrades if enabled
        function automateUpgrades() {
            if (!isAutoEnabled) return;

            const { button, cost } = findCheapestUpgrade();
            if (button && truthCount >= cost) {
                performUpgrade(button);
            }
        }

        // Game loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (truthCount === 6 && mines[0].bin.triangles !== 6) {
                mines[0].bin.triangles = 6;
            }

            // Handle automation
            automateUpgrades();

            updateWorldHeight();
            drawPaths();
            mines.forEach(mine => {
                drawBin(mine.bin);
                drawWorker(mine.worker);
            });
            drawBin(bins.shaft);
            drawBin(bins.cart);
            workers.shaft.forEach(worker => drawWorker(worker));
            workers.cart.forEach(worker => drawWorker(worker));
            drawCounter();
            drawBinCounters();
            drawButtons();

            mines.forEach(updateMineWorker);
            workers.shaft.forEach(updateShaftWorker);
            workers.cart.forEach(updateCartWorker);

            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
