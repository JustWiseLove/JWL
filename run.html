const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startButton = document.getElementById('startButton');
const jumpButton = document.getElementById('jumpButton');
const duckButton = document.getElementById('duckButton');
const gameOverScreen = document.getElementById('gameOver');
const scoreDisplay = document.getElementById('scoreDisplay');
const leaderboardDisplay = document.getElementById('leaderboard');
const restartButton = document.getElementById('restartButton');
const timerDisplay = document.getElementById('timer');

// Set canvas size for mobile
let scale = 1;
function setCanvasSize() {
    if (window.innerWidth >= 1024) {
        canvas.width = 1080;
        canvas.height = 1920;
        scale = 3;
    } else if (window.innerWidth >= 768) {
        canvas.width = 720;
        canvas.height = 1280;
        scale = 2;
    } else {
        canvas.width = 360;
        canvas.height = 640;
        scale = 1;
    }
    // Ensure sharpness
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = `${canvas.width}px`;
    canvas.style.height = `${canvas.height}px`;
    canvas.width *= dpr;
    canvas.height *= dpr;
    ctx.scale(dpr * scale, dpr * scale);
}
setCanvasSize();
window.addEventListener('resize', setCanvasSize);

// Game variables
let gameRunning = false;
let player = {
    x: 50 / scale,
    y: (canvas.height / scale) - 100 / scale,
    width: 50 / scale,
    height: 50 / scale,
    jumping: false,
    ducking: false,
    jumpHeight: 100 / scale,
    jumpSpeed: 200 / scale,
    gravity: 400 / scale
};
let obstacles = [];
let lastObstacleTime = 0;
let obstacleInterval = 1500;
let startTime = 0;
let score = 0;
let leaderboard = JSON.parse(localStorage.getItem('leaderboard')) || [];

// Obstacle constructor
function createObstacle() {
    const type = Math.random() < 0.5 ? 'jump' : 'duck';
    let obstacle;
    if (type === 'jump') {
        const height = (20 + Math.random() * 30) / scale;
        obstacle = {
            x: canvas.width / scale,
            y: (canvas.height / scale) - height,
            width: 30 / scale,
            height: height,
            type: 'jump'
        };
    } else {
        const height = (20 + Math.random() * 30) / scale;
        obstacle = {
            x: canvas.width / scale,
            y: 0,
            width: 30 / scale,
            height: height,
            type: 'duck'
        };
    }
    obstacles.push(obstacle);
}

// Update game state
function update(deltaTime) {
    if (!gameRunning) return;

    // Update timer
    score = (Date.now() - startTime) / 1000;
    timerDisplay.textContent = `Time: ${score.toFixed(2)}s`;

    // Player physics
    if (player.jumping) {
        player.y -= player.jumpSpeed * deltaTime;
        if (player.y <= (canvas.height / scale) - player.height - player.jumpHeight) {
            player.jumping = false;
        }
    } else if (player.y < (canvas.height / scale) - player.height) {
        player.y += player.gravity * deltaTime;
        if (player.y > (canvas.height / scale) - player.height) {
            player.y = (canvas.height / scale) - player.height;
        }
    }

    // Update obstacles
    obstacles.forEach(obstacle => {
        obstacle.x -= 200 / scale * deltaTime;
    });
    obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);

    // Spawn obstacles
    if (Date.now() - lastObstacleTime > obstacleInterval) {
        createObstacle();
        lastObstacleTime = Date.now();
        obstacleInterval = 1000 + Math.random() * 1000;
    }

    // Collision detection
    obstacles.forEach(obstacle => {
        let playerHeight = player.ducking ? player.height / 2 : player.height;
        let playerY = player.ducking ? player.y + player.height / 2 : player.y;
        if (
            player.x + player.width > obstacle.x &&
            player.x < obstacle.x + obstacle.width &&
            playerY + playerHeight > obstacle.y &&
            playerY < obstacle.y + obstacle.height
        ) {
            if (
                (obstacle.type === 'jump' && (player.jumping || player.ducking)) ||
                (obstacle.type === 'duck' && !player.ducking)
            ) {
                endGame();
            }
        }
    });

    // Draw
    ctx.clearRect(0, 0, canvas.width / scale, canvas.height / scale);
    // Draw player
    ctx.fillStyle = '#333333';
    if (player.ducking) {
        ctx.fillRect(player.x, player.y + player.height / 2, player.width, player.height / 2);
    } else {
        ctx.fillRect(player.x, player.y, player.width, player.height);
    }
    // Draw obstacles
    ctx.fillStyle = '#000000';
    obstacles.forEach(obstacle => {
        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
    });
}

// End game
function endGame() {
    gameRunning = false;
    gameOverScreen.classList.remove('hidden');
    scoreDisplay.textContent = `Your Time: ${score.toFixed(2)}s`;

    // Update leaderboard
    if (leaderboard.length < 5 || score > Math.min(...leaderboard.map(entry => entry.score))) {
        let name = prompt('You made the leaderboard! Enter your name:') || 'Anonymous';
        leaderboard.push({ name, score });
        leaderboard.sort((a, b) => b.score - a.score);
        leaderboard = leaderboard.slice(0, 5);
        localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
    }

    // Display leaderboard
    leaderboardDisplay.innerHTML = '<h3>Leaderboard</h3>' + leaderboard.map((entry, index) =>
        `${index + 1}. ${entry.name}: ${entry.score.toFixed(2)}s`
    ).join('<br>');

    restartButton.classList.remove('hidden');
}

// Start game
function startGame() {
    gameRunning = true;
    startButton.classList.add('hidden');
    gameOverScreen.classList.add('hidden');
    restartButton.classList.add('hidden');
    obstacles = [];
    lastObstacleTime = Date.now();
    startTime = Date.now();
    score = 0;
    player.y = (canvas.height / scale) - player.height;
    player.jumping = false;
    player.ducking = false;
    timerDisplay.textContent = 'Time: 0.00s';
}

// Event listeners
startButton.addEventListener('click', startGame);
restartButton.addEventListener('click', startGame);

jumpButton.addEventListener('click', () => {
    if (gameRunning && !player.jumping && !player.ducking) {
        player.jumping = true;
    }
});

duckButton.addEventListener('mousedown', () => {
    if (gameRunning && !player.jumping) {
        player.ducking = true;
    }
});
duckButton.addEventListener('mouseup', () => {
    player.ducking = false;
});
duckButton.addEventListener('touchstart', () => {
    if (gameRunning && !player.jumping) {
        player.ducking = true;
    }
});
duckButton.addEventListener('touchend', () => {
    player.ducking = false;
});

// Game loop
let lastTime = 0;
function gameLoop(timestamp) {
    const deltaTime = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    update(deltaTime);
    requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);
